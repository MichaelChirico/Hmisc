% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simMarkovOrd.r
\name{simMarkovOrd}
\alias{simMarkovOrd}
\title{simMarkovOrd}
\usage{
simMarkovOrd(
  y,
  times,
  initial,
  absorb = NULL,
  intercepts,
  g,
  id = NULL,
  carry = FALSE,
  ...
)
}
\arguments{
\item{y}{vector of possible y values in order}

\item{times}{vector of measurement times}

\item{initial}{initial value of \code{y} (baseline state)}

\item{absorb}{vector of absorbing states, a subset of \code{y}.  The default is no absorbing states.  Observations are truncated when an absorbing state is simulated.}

\item{intercepts}{vector of intercepts in the proportional odds model.  There must be one fewer of these than the length of \code{y}.}

\item{g}{a user-specified function of three or more arguments which in order are the value of \code{y} at the previous time, the current time, the gap between the previous time and the current time, and optional arguments such as treatment assignment (scalar).  The function returns the linear predictor for the proportional odds model aside from \code{intercepts}.}

\item{id}{if you desire a subject ID value to appear as a column of constants in the resulting matrix, specify an integer scalar as \code{id}}

\item{carry}{set to \code{TRUE} to carry absorbing state forward after it is first hit; the default is to end records for the subject once the absorbing state is hit}

\item{...}{additional arguments to pass to \code{g} such as covariate settings}
}
\value{
matrix with rows = times, columns time and y
}
\description{
Simulate Ordinal Markov Process
}
\details{
Simulates longitudinal data for one subject following a first-order Markov process under a proportional odds model.
}
\examples{
g <- function(yprev, t, gap) yprev - ((gap - 1)/ 7) * yprev + t / 10
simMarkovOrd(1:3, c(1, 2, 3, 7, 14), 2, absorb=3,
             intercepts=c(-1, -2), g=g)

# Simulate 100 subjects (for 100,000 subjects this takes 2s)
s <- sapply(1 : 100, function(id)
      simMarkovOrd(1:3, c(1, 2, 3, 7, 14), 2, absorb=3,
                   intercepts=c(-1, -2), g=g, id=id) )
do.call(rbind, s)   # create one matrix out of 100 matrices having varying # rows
}
\author{
Frank Harrell
}
